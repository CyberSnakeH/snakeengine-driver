# SnakeEngine Driver (Linux)

> Hardened memory-access and hardware-breakpoint driver for Linux, inspired by Cheat Engineâ€™s DBK on Windows. Kernel module + modern C++ userland API.

ðŸ”— **Wiki:** https://github.com/CyberSnakeH/snakeengine-driver/wiki  
ðŸ› ï¸ **deploy.sh:** one-touch build/install/load  
ðŸ›¡ï¸ **Security:** udev + AppArmor + SELinux (optional)  
ðŸ“¦ **DKMS:** resilient across kernel updates

## Highlights
- **Kernel module (`kernel/snakedrv_main.c`)**: character device `/dev/snakedrv`, attach/detach target processes, forced read/write, region discovery, hardware breakpoints via perf/hw_breakpoint.
- **Shared API (`userland/include/snakedrv.h`)**: common contract (IOCTLs, structs, error codes, versioning) used by kernel and userland.
- **Userland library (`userland/src/libsnakedrv.cpp`, `include/libsnakedrv.hpp`)**: C++ wrapper that opens `/dev/snakedrv`, sends IOCTLs, and exposes a high-level API (attach/detach, read/write, query regions, set HW breakpoints, pop debug events).
- **DKMS (`dkms/`)**: automatic rebuild on kernel updates.
- **Security (`security/`)**: udev rules, AppArmor profile, optional SELinux policy.
- **Automation (`deploy.sh`)**: single entry point for dependencies, build, install, load/unload, status, and cleanup.

## Core Capabilities
- Attach/detach target processes with refcounting and locking.
- Read/write process memory via `access_process_vm`, with forced access and operation counters.
- Enumerate memory regions (`snake_memory_region`) with protection, type, inode, and path metadata.
- Hardware breakpoints DR0â€“DR3 (execute/write/read-write), lengths 1/2/4/8, using perf events; notify userland on hits.
- Debug event queue exposed via IOCTL/poll: instruction address, accessed address, access type/size, DR slot, sequence.
- Process/thread control (suspend/resume/kill/info/list-threads) through dedicated IOCTLs.
- Module parameters (tunable or set via `/etc/modprobe.d/snakedrv.conf`):
  - `max_attached_processes` (default: 16)
  - `event_queue_size` (default: 256)
  - `debug_level` (0â€“3)

## Source Layout
- `kernel/`
  - `snakedrv_main.c`: char device, IOCTL handling, attach management, breakpoints, event queue, memory ops.
  - `Makefile`: builds `snakedrv.ko`.
- `userland/`
  - `include/snakedrv.h`: shared C API (structs, IOCTLs, errors).
  - `include/libsnakedrv.hpp`: public C++ interface.
  - `src/libsnakedrv.cpp`: implementation (device open, IOCTL wrappers, error mapping).
  - `CMakeLists.txt`: optional CMake build.
- `dkms/dkms.conf`: DKMS recipe for automatic rebuilds.
- `security/`
  - `99-snakedrv.rules`: udev rule, `snakeengine` group, device permissions.
  - `snakeengine.apparmor`: AppArmor profile.
  - `snakeengine.te` / `snakeengine.fc`: SELinux policy and file contexts.
- `deploy.sh`: full automation (see below).
- `test/`: legacy sample binaries (not built by default).

## API / IOCTLs (high level)
Defined in `userland/include/snakedrv.h` with magic `0x53`:
- **Memory**: `snake_memory_op` (pid, addr, size, flags), `snake_memory_query` and `snake_memory_region`.
- **Process/threads**: `snake_process_op`, `snake_process_info`, `snake_thread_info`.
- **Breakpoints**: `snake_hw_breakpoint` (pid/tid, addr, type, len), release/list operations.
- **Debug events**: `snake_debug_event` (instruction address, accessed address, access type/size, DR slot, sequence).
`libsnakedrv` wraps these IOCTLs into methods (attach/detach, read/write, queryRegions, setHardwareBreakpoint, popEvents, etc.).

## Security Hardening
- **udev**: creates `/dev/snakedrv` with the `snakeengine` group and restricted permissions.
- **AppArmor**: optional profile to confine device access and related binaries.
- **SELinux**: optional policy (built if `selinux-policy-devel`/`checkpolicy` is available).
- **Module defaults**: `/etc/modprobe.d/snakedrv.conf` generated by `deploy.sh` sets sane defaults for parameters.

## What `deploy.sh` Does
Primary commands: `deps`, `build`, `install`, `uninstall`, `load`, `unload`, `reload`, `status`, `clean`, `vm`, `help`.
- **Options**: `--debug`, `--no-dkms`, `--no-selinux`, `--no-apparmor`, `--force`, `--prefix=PATH`, `-j/--jobs N`.
- **Dependencies**: detects distro (Debian/Fedora/Arch) and installs headers, dkms, clang/llvm, cmake, libelf.
- **Build**:
  - `kernel/Makefile` â†’ `snakedrv.ko` (DEBUG=1 when requested).
  - `userland/` via CMake if present, otherwise manual compile to `libsnakedrv.so` and `libsnakedrv.a`.
- **Install**:
  - Module via DKMS (default) or direct copy to `/lib/modules/$(uname -r)/extra` + `depmod`.
  - Library/headers to `${PREFIX}` (`/usr/local` by default) + `ldconfig`.
  - udev rules + `snakeengine` group.
  - `/etc/modprobe.d/snakedrv.conf` with `max_attached_processes`, `event_queue_size`, `debug_level`.
  - SELinux (build/install `snakeengine.pp` if possible) and AppArmor (load profile).
- **Module control**: `load` (insmod/modprobe), `unload`, `status` (lsmod, device presence, DKMS state, dmesg tail).
- **Cleanup**: `clean` removes build artifacts; `uninstall` removes module, DKMS, libs, udev/AppArmor/SELinux artifacts, and refreshes caches.
- **VM deploy**: `vm` rsyncs the folder to a VM.

### Quick examples
```bash
# Full build
./deploy.sh build

# Full install with DKMS, udev, AppArmor/SELinux (root)
sudo ./deploy.sh install

# Install without DKMS and without SELinux/AppArmor
sudo ./deploy.sh install --no-dkms --no-selinux --no-apparmor

# Load / unload
sudo ./deploy.sh load
sudo ./deploy.sh unload

# Status
./deploy.sh status

# Full uninstall
sudo ./deploy.sh uninstall
```

## Developer Workflow
1) `sudo ./deploy.sh deps` (install prerequisites).  
2) `./deploy.sh build`.  
3) `sudo ./deploy.sh install && sudo ./deploy.sh load`.  
4) Link your app against `libsnakedrv` (include `libsnakedrv.hpp`, link `-lsnakedrv`), then use the API (attach, read/write, breakpoints, popEvents).  
5) Debug: `./deploy.sh status` and `dmesg | grep snakedrv` (verbosity via `debug_level`).  

## Best Practices
- Restrict `/dev/snakedrv` to the `snakeengine` group only.
- Enable SELinux/AppArmor where available to shrink the attack surface.
- Avoid exposing the device on untrusted multi-user systems.
- Keep `debug_level` at 1 in production (0 for silent, >1 for verbose).

## Tree
```
kernel/               Kernel module (snakedrv_main.c, Makefile)
userland/             C/C++ shared headers and library
dkms/                 dkms.conf for automatic rebuild
security/             udev + AppArmor + SELinux
test/                 Legacy sample binaries (not built by default)
deploy.sh             Full automation script
```

## C++ Usage (with `libsnakedrv`)

Applications typically:
1) Include `userland/include/libsnakedrv.hpp`.  
2) Link against `libsnakedrv.so` (or the static `libsnakedrv.a`).  
3) Use the C++ API to attach, read/write memory, and manage hardware breakpoints.

Basic example:
```cpp
#include "libsnakedrv.hpp"
#include <iostream>

int main() {
    snake::Driver drv;
    if (!drv.open()) {
        std::cerr << "Failed to open driver (is /dev/snakedrv present?).\n";
        return 1;
    }

    const snake::ProcessId target = /* your target pid */;
    if (!drv.attach(target)) {
        std::cerr << "Attach failed\n";
        return 1;
    }

    // Read a 32-bit value
    uint32_t value = drv.read<uint32_t>(0x7ffdf000);
    std::cout << "Value: " << value << "\n";

    // Write a 32-bit value
    uint32_t newValue = 1337;
    drv.write(0x7ffdf000, newValue);

    // Set a write watchpoint (4 bytes)
    auto bp = drv.setBreakpoint(0x7ffdf000,
                                snake::BreakpointType::ReadWrite,
                                snake::BreakpointLength::Byte4);
    if (!bp) {
        std::cerr << "Breakpoint set failed\n";
        return 1;
    }

    // Poll events
    for (const auto& ev : drv.pollEvents(16)) {
        std::cout << "Hit at 0x" << std::hex << ev.address
                  << " accessed 0x" << ev.accessedAddress
                  << " size=" << std::dec << ev.accessSize
                  << (ev.isWrite ? " [W]" : " [R]") << "\n";
    }

    drv.clearBreakpoint(*bp);
    drv.detach();
    return 0;
}
```

## Troubleshooting
- **Module does not load**: check `dmesg | grep snakedrv`, ensure kernel headers match the running kernel, watch for secure boot/signing.
- **Device missing**: trigger udev (`udevadm trigger`), verify `snakeengine` group/permissions.
- **DKMS failures**: remove the old version (`dkms remove -m snakedrv -v 1.0.0 --all`), rerun `install`.
- **SELinux/AppArmor blocks**: reinstall with `--no-selinux` or `--no-apparmor`, or adjust the policies appropriately.
- **Kernel panics**: always develop/test in a VM or dedicated test box.

## Contributing
Contributions are welcome! Please follow the existing coding style, document changes, and use pull requests.


## Changelog
* **1.1 (2025-12-06):**
  * Fixed AppArmor policy errors and improved profile compatibility.
  * Resolved objtool compilation errors (RETPOLINE/indirect calls) on certain Linux distributions (Ubuntu 24.04+, newer kernels).
  * Added `sign-module.sh` script for Secure Boot support (MOK key generation and module signing).

* **1.0 (2025-12-01):** Initial release of the `snakeengine-driver`.
  * Kernel module for low-level system interaction.
  * Userland library `libsnakedrv` for application integration.
  * DKMS support for kernel update compatibility.
  * Security policies (udev, AppArmor, SELinux).
  * Automated deployment script (`deploy.sh`).
